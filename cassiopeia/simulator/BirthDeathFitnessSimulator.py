"""
A general simulator for a birth-death tree simulation process, including 
fitness. Takes any given distribution on waiting times and fitness 
mutations.
"""

import networkx as nx
import numpy as np

from cassiopeia.data.CassiopeiaTree import CassiopeiaTree
from cassiopeia.simulator import TreeSimulator

class BirthDeathFitnessError(Exception):
    """An Exception class for all exceptions generated by the
    GeneralBirthDeathSimulator
    """
    pass


class BirthDeathFitnessSimulator(TreeSimulator):

    def simulate_tree(
        self,
        birth_waiting_dist,
        birth_scale_param,
        death_waiting_dist=None,
        fitness_num_dist=None,
        fitness_strength_dist=None,
        num_extant=None,
        experiment_time=None,
    ):
        if num_extant is None and experiment_time is None:
            raise BirthDeathFitnessError("Please specify a stopping condition")
        if num_extant and experiment_time:
            raise BirthDeathFitnessError("Please choose only one stopping condition")
        if fitness_num_dist is not None and fitness_strength_dist is None:
            raise BirthDeathFitnessError("Please specify a fitness strength distribution")
        if num_extant is not None and num_extant <= 0:
            raise BirthDeathFitnessError("Please specify number of extant lineages greater than 0")
        if experiment_time is not None and experiment_time <= 0:
            raise BirthDeathFitnessError("Please specify an experiment time greater than 0")


        def sample_event(unique_id, lineage):
            birth_waiting_time = birth_waiting_dist(lineage["birth_scale"])
            death_waiting_time = death_waiting_dist()
            if birth_waiting_time <= 0 or death_waiting_time <= 0:
                raise BirthDeathFitnessError("0 or negative waiting time detected")

            if experiment_time and lineage["total_time"] + birth_waiting_time >= experiment_time and lineage["total_time"] + death_waiting_time >= experiment_time:
                tree.add_node(unique_id)
                tree.nodes[unique_id]["birth_scale"] = lineage["birth_scale"]
                tree.add_edge(lineage["id"], unique_id, weight = experiment_time - lineage["total_time"])
                tree.nodes[unique_id]["total_time"] = experiment_time
                return unique_id + 1

            if birth_waiting_time < death_waiting_time:
                total_birth_mutation_strength = 1
                if fitness_num_dist:
                    num_mutations = int(fitness_num_dist())
                    if num_mutations < 0:
                        raise BirthDeathFitnessError("Negative number of mutations detected")
                    for _ in range(num_mutations):
                        total_birth_mutation_strength *= fitness_strength_dist()
                    if total_birth_mutation_strength < 0:
                        raise BirthDeathFitnessError("Negative mutation strength detected")
                
                tree.add_node(unique_id)
                tree.nodes[unique_id]["birth_scale"] = lineage["birth_scale"] * total_birth_mutation_strength
                tree.add_edge(lineage["id"], unique_id, weight = birth_waiting_time)
                tree.nodes[unique_id]["total_time"] = birth_waiting_time + lineage["total_time"]
                current_lineages.append(
                    {
                        "id": unique_id,
                        "birth_scale": lineage["birth_scale"] * total_birth_mutation_strength,
                        "total_time": birth_waiting_time + lineage["total_time"]
                    }
                )
                return unique_id + 1
            else:
                return unique_id
            
        
        tree = nx.DiGraph()
        tree.add_node(0)
        tree.nodes[0]["birth_scale"] = birth_scale_param
        tree.nodes[0]["total_time"] = 0
        # Sample the waiting time until the first division

        current_lineages = []
        starting_lineage = {
            "id": 0,
            "birth_scale": birth_scale_param,
            "total_time": 0
        }
        unique_id = 1
        unique_id = sample_event(unique_id, starting_lineage)

        # Perform the process until there are no active extant lineages left
        while len(current_lineages) > 0:
            # If number of extant lineages is the stopping criterion, at the
            # first instance of having n extant tips, stop the experiment
            # and set the total lineage time for each lineage to be equal to
            # the minimum, to produce ultrametric trees
            if num_extant:
                if len(current_lineages) == num_extant:
                    min_total_time = min([i["total_time"] for i in current_lineages])
                    for remaining_lineage in current_lineages:
                        parent = list(tree.predecessors(remaining_lineage["id"]))[0]
                        tree.edges[parent, remaining_lineage["id"]]["weight"] += (
                            min_total_time - remaining_lineage["total_time"]
                        )
                    break
            # If extant tips are the stopping criteria, pop the minimum age 
            # lineage at each step
            if num_extant:
                min_age_ind = np.argmin([i["total_time"] for i in current_lineages])
                lineage = current_lineages.pop(min_age_ind)
            else:
                lineage = current_lineages.pop(0)
            for _ in range(2):
                unique_id = sample_event(unique_id, lineage)

        if death_waiting_dist and len(tree.nodes) > 1:
            if experiment_time:
                for i in list(tree.nodes):
                    if tree.out_degree(i) == 0 and tree.nodes[i]["total_time"] < experiment_time:
                        self.remove_and_prune(i, tree)
            if num_extant:
                surviving_ids = [i["id"] for i in current_lineages] 
                for i in list(tree.nodes):
                    if tree.out_degree(i) == 0 and i not in surviving_ids:
                        self.remove_and_prune(i, tree)
            if len(tree.nodes) > 1:
                self.collapse_unifurcations(tree, source = 1)

        if len(tree.nodes) == 1:
            raise BirthDeathFitnessError("All lineages died before stopping condition")

        return CassiopeiaTree(tree = tree)


    def remove_and_prune(self, node, network):
        if len(network.nodes) > 1:
            curr_parent = list(network.predecessors(node))[0]
            network.remove_node(node)
            while (
                network.out_degree(curr_parent) < 1
                and network.in_degree(curr_parent) > 0
            ):
                next_parent = list(network.predecessors(curr_parent))[0]
                network.remove_node(curr_parent)
                curr_parent = next_parent

    def collapse_unifurcations(self, network, source = None):
        def _collapse_unifurcations(network, node, parent):
            succs = list(network.successors(node))
            if len(succs) == 1:
                t = network.get_edge_data(parent, node)["weight"]
                t_ = network.get_edge_data(node, succs[0])["weight"]
                network.add_edge(parent, succs[0], weight=t + t_)
                _collapse_unifurcations(network, succs[0], parent)
                network.remove_node(node)
            else:
                for i in succs:
                    _collapse_unifurcations(network, i, node)

        if not source:
            source = [n for n in network if network.in_degree(n) == 0][0]
        
        for node in network.successors(source):
            _collapse_unifurcations(network, node, source)
        
        succs = list(network.successors(source))
        if len(succs) == 1:
            t = network.get_edge_data(source, succs[0])["weight"]
            for i in network.successors(succs[0]):
                t_ = network.get_edge_data(succs[0], i)["weight"]
                network.add_edge(source, i, weight=t + t_)
            network.remove_node(succs[0])



"""Example use snippet:
note that numpy uses a different parameterization of the exponential with the scale parameter, which is 1/rate


birth_waiting_dist = np.random.exponential
death_waiting_dist = np.random.exponential(1.5)
birth_scale_param = 0.5
fitness_num_dist = lambda: 1 if np.random.uniform() > 0.5 else 0
fitness_strength_dist = lambda: 2 ** np.random.uniform(-1,1)

tree = generate_birth_death(
    birth_waiting_dist,
    birth_scale_param,
    death_waiting_dist,
    fitness_num_dist = fitness_num_dist,
    fitness_strength_dist=fitness_strength_dist,
    num_extant=8,
#     experiment_time = 1
)

"""