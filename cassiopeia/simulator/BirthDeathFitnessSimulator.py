"""
A general simulator for a birth-death tree simulation process, including 
fitness. Takes any given distribution on waiting times and fitness 
mutations.
"""

import networkx as nx
import numpy as np

from cassiopeia.data.CassiopeiaTree import CassiopeiaTree
from cassiopeia.simulator import TreeSimulator

class BirthDeathFitnessError(Exception):
    """An Exception class for all exceptions generated by the
    GeneralBirthDeathSimulator
    """
    pass


class BirthDeathFitnessSimulator(TreeSimulator):

    def simulate_tree(
        self,
        birth_waiting_dist,
        birth_scale_param,
        death_waiting_dist=None,
        fitness_num_dist=None,
        fitness_strength_dist=None,
        num_extant=None,
        experiment_time=None,
    ):
        if num_extant is None and experiment_time is None:
            raise BirthDeathFitnessError("Please specify a stopping condition")
        if fitness_num_dist is not None and fitness_strength_dist is None:
            raise BirthDeathFitnessError("Please specify a fitness strength distribution")
        if num_extant is not None and num_extant <= 0:
            raise BirthDeathFitnessError("Please specify number of extant lineages greater than 0")
        if experiment_time is not None and experiment_time <= 0:
            raise BirthDeathFitnessError("Please specify an experiment time greater than 0")

        tree = nx.DiGraph()
        tree.add_node(0)
        # Sample the waiting time until the first division
        birth_time_before_first_division = birth_waiting_dist(birth_scale_param)
        death_time_before_first_division = death_waiting_dist()
        if birth_time_before_first_division <= 0 or death_time_before_first_division <= 0:
            raise BirthDeathFitnessError("0 or negative waiting time detected")
        if birth_time_before_first_division < death_time_before_first_division:
            tree.add_node(1)
            tree.add_edge(0, 1, weight = birth_waiting_dist(birth_time_before_first_division))
            # Keep a list of extant lineages and a dict of lineage specific parameters
            # for each
            unique_id = 1
            current_lineages = []
            current_lineages.append(
                {
                    "id": unique_id,
                    "birth_scale": birth_scale_param,
                    "total_time": birth_time_before_first_division,
                }
            )
            # Record the scale parameter of each node
            tree.nodes[unique_id]["birth_scale"] = birth_scale_param
            # Perform the process until there are no active extant lineages left
            while len(current_lineages) > 0:
                # If number of extant lineages is the stopping criterion, at the
                # first instance of having n extant tips, stop the experiment
                # and set the total lineage time for each lineage to be equal to
                # the maximum, to produce ultrametric trees
                if num_extant:
                    if len(current_lineages) == num_extant:
                        max_total_time = 0
                        for remaining_lineage in current_lineages:
                            if remaining_lineage["total_time"] > max_total_time:
                                max_total_time = remaining_lineage["total_time"]
                        for remaining_lineage in current_lineages:
                            parent = list(tree.predecessors(remaining_lineage["id"]))[0]
                            tree.edges[parent, remaining_lineage["id"]]["weight"] += (
                                max_total_time - remaining_lineage["total_time"]
                            )
                        break

                lineage = current_lineages.pop(0)  # Make sure to pop from front
                birth_waiting_time = birth_waiting_dist(lineage["birth_scale"])
                death_waiting_time = death_waiting_dist()
                if birth_waiting_time <= 0 or death_waiting_time <= 0:
                    raise BirthDeathFitnessError("0 or negative waiting time detected")
                # Take the minimum waiting time to dictate which event happens
                if birth_waiting_time < death_waiting_time:
                    # If time is the stopping condition, if the next birth would
                    # happen after the time of the experiment, cut the lineage off
                    # at the total stopping time and produce no additional daughters
                    if experiment_time:
                        if (
                            birth_waiting_time + lineage["total_time"]
                            >= experiment_time
                        ):
                            parent = list(tree.predecessors(lineage["id"]))[0]
                            tree.edges[parent, lineage["id"]]["weight"] += (
                                experiment_time - lineage["total_time"]
                            )
                            continue
                    # Determine the number of mutations acquired, and then determine
                    # their strength
                    total_birth_mutation_strength = 1
                    if fitness_num_dist:
                        num_mutations = int(fitness_num_dist())
                        if num_mutations < 0:
                            raise BirthDeathFitnessError("Negative number of mutations detected")
                        for _ in range(num_mutations):
                            total_birth_mutation_strength *= fitness_strength_dist()
                        if total_birth_mutation_strength < 0:
                            raise BirthDeathFitnessError("Negative mutation strength detected")
                    # Add two daughters with updated total time, and scale parameters
                    for i in range(unique_id + 1, unique_id + 3):
                        tree.add_node(i)
                        current_lineages.append(
                            {
                                "id": i,
                                "birth_scale": lineage["birth_scale"]
                                * total_birth_mutation_strength,
                                "total_time": lineage["total_time"]
                                + birth_waiting_time,
                            }
                        )
                        tree.add_edge(lineage["id"], i, weight=birth_waiting_time)
                        # Record the scale parameter of each node
                        tree.nodes[i]["birth_scale"] = lineage["birth_scale"] * total_birth_mutation_strength
                    unique_id += 2

                else:
                    # If the lineage dies, prune the entire lineage from the tree
                    self.remove_and_prune(lineage["id"], tree)

            if death_waiting_dist:
                self.collapse_unifurcations(tree, source = 1)

        if len(tree.nodes) == 1:
            raise BirthDeathFitnessError("All lineages died before stopping condition")

        return CassiopeiaTree(tree = tree)


    def remove_and_prune(self, node, network):
        if len(network.nodes) > 1:
            curr_parent = list(network.predecessors(node))[0]
            network.remove_node(node)
            while (
                network.out_degree(curr_parent) < 1
                and network.in_degree(curr_parent) > 0
            ):
                next_parent = list(network.predecessors(curr_parent))[0]
                network.remove_node(curr_parent)
                curr_parent = next_parent

    def collapse_unifurcations(self, network, source = None):
        def _collapse_unifurcations(network, node, parent):
            succs = list(network.successors(node))
            if len(succs) == 1:
                t = network.get_edge_data(parent, node)["weight"]
                t_ = network.get_edge_data(node, succs[0])["weight"]
                network.add_edge(parent, succs[0], weight=t + t_)
                _collapse_unifurcations(network, succs[0], parent)
                network.remove_node(node)
            else:
                for i in succs:
                    _collapse_unifurcations(network, i, node)
        
        if source:
            for node in network.successors(source):
                _collapse_unifurcations(network, node, source)
        else:
            root = [n for n in network if network.in_degree(n) == 0][0]
            for node in network.successors(root):
                _collapse_unifurcations(network, node, root)



"""Example use snippet:
note that numpy uses a different parameterization of the exponential with the scale parameter, which is 1/rate


birth_waiting_dist = np.random.exponential
death_waiting_dist = np.random.exponential(1.5)
birth_scale_param = 0.5
fitness_num_dist = lambda: 1 if np.random.uniform() > 0.5 else 0
fitness_strength_dist = lambda: 2 ** np.random.uniform(-1,1)

tree = generate_birth_death(
    birth_waiting_dist,
    birth_scale_param,
    death_waiting_dist,
    fitness_num_dist = fitness_num_dist,
    fitness_strength_dist=fitness_strength_dist,
    num_extant=8,
#     experiment_time = 1
)

"""